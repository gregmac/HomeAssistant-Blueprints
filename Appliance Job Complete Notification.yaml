blueprint:
  name: "Appliance Job Complete Notification"
  author: gregmac
  domain: automation
  description: >-
    Send notification of the job completion of a Washer/Dryer/etc to
    one or more notification services.


    Automatically configures a message to send to common targets,
    but also can be configured for custom actions.

  input:
    job_state:
      name: Appliance State
      description: |
        The sensor with job state belonging to the appliance to be monitored.
      selector:
        entity:
          domain: sensor

    activation_switch:
      name: Activation switch
      description: |
        An optional input to control if the notification is enabled.
        This can be used with **Automatically deactivation next notification**
        to have an only-once notification, that has to be enabled each time.
      default: []
      selector:
        entity:
          domain: input_boolean

    notify1_type: 
      name: "Notification 1: Type"
      description: >
        Service name to use for notification.
        
        
        If entering a custom value, this should be the direct service name, for example `notify.cell_phone_1`.
      default: none.none
      selector:
        select:
          options:
            - value: none.none # passes template valdiation, but doesn't get executed
              label: "Disabled"
            - value: notify.google_assistant_sdk
              label: "Send a notification with notify.google_assistant_sdk"
            - value: notify.notify
              label: "Send a notification with notify.notify"
          custom_value: true

    notify1_targets:
      name: "Notification 1: Targets(s) to notify"
      description: |
        Optional. Usually meeans "area" to notify, blank usually means "everywhere".
      default: []
      selector:
        area:
          multiple: true

    notify1_schedule:
      name: "Notification 1: Schedule"
      description: |
        Optional. If set, Notification 1 is only sent when this is active.
      default: []
      selector:
        entity:
          domain: schedule

    notify2_type: 
      name: "Notification 2: Type"
      description: >
        Optional. Service name to use for notification.
      default: none.none
      selector:
        select:
          options:
            - value: none.none
              label: "Disabled"
            - value: notify.google_assistant_sdk
              label: "Send a notification with notify.google_assistant_sdk"
            - value: notify.notify
              label: "Send a notification with notify.notify"
          custom_value: true

    notify2_targets:
      name: "Notification 2: Targets(s) to notify"
      description: |
        Optional. Usually meeans "area" to notify, blank usually means "everywhere".
      default: []
      selector:
        text:

    notify2_schedule:
      name: "Notification 2: Schedule"
      description: |
        Optional. If set, Notification 2 is only sent when this is active.
      default: []
      selector:
        entity:
          domain: schedule

    custom_actions: 
      name: "Custom Actions"
      description: >
        Optional. Any other action(s) to perform when the job is complete.


        Variables available for use in messages:
        
        * `{{appliance_device_id}}` - The device id that the **Appliance State** sensor belongs to

        * `{{appliance_name}}` - The name of the device (if available)

        * `{{notification_message}}` - Either "The {{appliance_name}} has finished" or the name of this automation.
      default: []
      selector:
        action:

    deactivate_on_complete:
      name: Automatically deactivation next notification
      description: |
        Turns off the **Activation switch** after notifying once.
        This allows selectively turning on the notification each time you want to use it.
        When this is enabled, the switch also automatically turns off
        after **Maximum time to wait**.
      default: true
      selector:
        boolean:

    max_wait:
      name: Maximum time to wait
      description: |
        If **Automatically deactivation next notification** is on, and the appliance has 
        not completed in this time after turning on the **Activation switch**,
        the notification is turned off anyways.
      default: { hours: 6 }
      selector:
        duration:

mode: restart

trigger:
  - id: job_completed
    platform: state
    entity_id: !input job_state
    to:
      - finish
      - finished
      - complete
      - completed
      - done

  - platform: state
    entity_id: !input activation_switch

variables:
  activation_switch: !input activation_switch
  job_state: !input job_state
  deactivate_on_complete: !input deactivate_on_complete
  notify1_type: !input notify1_type
  notify1_schedule: !input notify1_schedule
  notify2_type: !input notify2_type
  notify2_schedule: !input notify2_schedule
  custom_actions: !input custom_actions

action:
  - variables:
      is_trig: "{{ trigger.entity_id == activation_switch }}"
      is_deactivate_on_complete: "{{ deactivate_on_complete }}"
      is_state: "{{  trigger.to_state.state == 'on' }}"

  - choose:
      - alias: "Job completed"
        conditions: "{{ trigger.entity_id == job_state }}"
        sequence:
          - variables:
              appliance_device_id: "{{ device_id(job_state) }}"
              appliance_name: "{{ device_attr(appliance_device_id, 'name') if appliance_device_id }}"
              notification_message: |
                {%- if appliance_name -%}
                  The {{ appliance_name }} has finished
                {%- else -%}
                  {{ this.attributes.friendly_name }}
                {%- endif -%}

          - service: logbook.log
            data:
              name: "{{ this.attributes.friendly_name }}"
              message: "{{ notification_message }}"
              entity_id: !input job_state

          - alias: Notifcation 1
            if:
              - condition: template
                # verify valid action, plus schedule is not off
                # (if unuset, schedule result is 'undefined' so condition is true)
                value_template: |
                  {{
                    (notify1_type and notify1_type != 'none.none')
                    and (states(notify1_schedule) != 'off')
                  }}
            then:
              - service: !input notify1_type
                data:
                  message: "{{ notification_message }}"
                  target: !input notify1_targets

          - alias: Notifcation 2
            if:
              - condition: template
                # verify valid action, plus schedule is not off
                # (if unuset, schedule result is 'undefined' so condition is true)
                value_template: |
                  {{
                    (notify2_type and notify2_type != 'none.none')
                    and (states(notify2_schedule) != 'off')
                  }}
            then:
              - service: !input notify2_type
                data:
                  message: "{{ notification_message }}"
                  target: !input notify2_targets

          - alias: Custom actions
            if:
              - condition: template
                value_template: "{{ custom_actions != [] }}"
            then: !input custom_actions

      - alias: "Deactivate delay"
        conditions: |
          {{
            deactivate_on_complete 
            and trigger.entity_id == activation_switch 
            and trigger.to_state.state == 'on'
          }}
        sequence:
          # delay for our waiting time
          # due to mode:restart, if the job completes in this time, it will interrupt this delay
          - delay: !input max_wait

          - service: logbook.log
            data:
              name: "{{ this.attributes.friendly_name }}"
              message: "Timeout expired without recieving job completion from {{ job_state }}. Disabling {{ activation_switch }}."
              entity_id: !input activation_switch 

          # disable notification
          - service: input_boolean.turn_off
            target: { entity_id: !input activation_switch }

